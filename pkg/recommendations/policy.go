package recommendations

import (
	"time"

	"github.com/common-fate/iamzero/pkg/policies"
	"github.com/common-fate/iamzero/pkg/tokens"
)

const (
	PolicyStatusActive   = "active"
	PolicyStatusResolved = "resolved"
)

// Policy is a least-privilege policy generated by IAM Zero
type Policy struct {
	ID          string                `json:"id" storm:"id"`
	Identity    ProcessedAWSIdentity  `json:"identity"`
	LastUpdated time.Time             `json:"lastUpdated"`
	Token       *tokens.Token         `json:"token"`
	EventCount  int                   `json:"eventCount"`
	Document    policies.AWSIAMPolicy `json:"document"`
	// CDKFinding  CDKFinding            `json:"cdkFinding"`
	// TerraformFinding *terraformApplier.TerraformFinding `json:"terraformFinding"`
	// Status is either "active" or "resolved"
	Status string `json:"status"`
}

// ProcessedAWSIdentity is the same as AWS identity but contains optional
// definitions for infrastructure-as-code references to the identity
//
// This is used by IAM Zero to inform the user that we have matched a role
// that we've received actions for, with a reference to the said role in a
// CDK/Terraform stack that the user has deployed.
type ProcessedAWSIdentity struct {
	User        string                `json:"user"`
	Role        string                `json:"role"`
	Account     string                `json:"account"`
	CDKResource *policies.CDKResource `json:"cdkResource"`
}

// RecalculateDocument rebuilds the policy document based on the actions
// this initial implementation is naive and doesn't deduplicate or aggregate policies.
func (p *Policy) RecalculateDocument(actions []AWSAction) {
	statements := []policies.AWSIAMStatement{}

	for _, alert := range actions {
		if alert.Enabled && len(alert.Recommendations) > 0 {
			advisory := alert.GetSelectedAdvisory()
			for _, description := range advisory.Details().Description {
				// TODO: this should be redesigned to avoid casting from the interface.
				policy, ok := description.Policy.(policies.AWSIAMPolicy)
				if ok {
					statements = append(statements, policy.Statement...)
				}
			}
		}
	}

	p.LastUpdated = time.Now()
	p.EventCount = len(actions)
	p.Document.Statement = statements
}

func PolicyStatusIsValid(status string) bool {
	return status == PolicyStatusActive || status == PolicyStatusResolved
}
